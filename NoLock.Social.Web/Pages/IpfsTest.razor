@page "/ipfs-test"
@using NoLock.Social.Core.Storage.Ipfs
@using System.Text
@using System.Diagnostics
@using System.IO
@implements IAsyncDisposable
@inject IIpfsFileSystem IpfsService
@inject IJSRuntime JSRuntime

<PageTitle>IPFS MFS Test</PageTitle>

<h3>IPFS MFS Manual Testing</h3>

<div class="container">
    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>Write Operations</h5>
                </div>
                <div class="card-body">
                    <div class="form-group mb-3">
                        <label>File Path:</label>
                        <input type="text" class="form-control" @bind="writePath" placeholder="/test/file.txt" />
                    </div>
                    <div class="form-group mb-3">
                        <label>File Size (KB):</label>
                        <input type="number" class="form-control" @bind="fileSizeKb" min="1" max="10240" />
                    </div>
                    <div class="form-group mb-3">
                        <label>Content Type:</label>
                        <select class="form-control" @bind="contentType">
                            <option value="text">Text (Repeating Pattern)</option>
                            <option value="random">Random Bytes</option>
                            <option value="json">JSON Data</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" @onclick="WriteFile" disabled="@isWriting">
                        @if (isWriting)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        Write File
                    </button>
                </div>
            </div>
        </div>

        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>Read Operations</h5>
                </div>
                <div class="card-body">
                    <div class="form-group mb-3">
                        <label>File Path:</label>
                        <input type="text" class="form-control" @bind="readPath" placeholder="/test/file.txt" />
                    </div>
                    <div class="form-check mb-3">
                        <input type="checkbox" class="form-check-input" @bind="verifyContent" id="verifyCheck" />
                        <label class="form-check-label" for="verifyCheck">
                            Verify Content (Performance Impact)
                        </label>
                    </div>
                    <button class="btn btn-success" @onclick="ReadFile" disabled="@isReading">
                        @if (isReading)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        Read File
                    </button>
                    <button class="btn btn-info ms-2" @onclick="ListFiles" disabled="@isListing">
                        @if (isListing)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        List Files
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="row mt-4">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>Performance Metrics</h5>
                </div>
                <div class="card-body">
                    <table class="table table-sm">
                        <tbody>
                            <tr>
                                <td>Total Writes:</td>
                                <td>@totalWrites</td>
                            </tr>
                            <tr>
                                <td>Total Reads:</td>
                                <td>@totalReads</td>
                            </tr>
                            <tr>
                                <td>Bytes Written:</td>
                                <td>@FormatBytes(totalBytesWritten)</td>
                            </tr>
                            <tr>
                                <td>Bytes Read:</td>
                                <td>@FormatBytes(totalBytesRead)</td>
                            </tr>
                            <tr>
                                <td>Avg Write Time:</td>
                                <td>@(totalWrites > 0 ? $"{totalWriteTime / totalWrites:F2} ms" : "N/A")</td>
                            </tr>
                            <tr>
                                <td>Avg Read Time:</td>
                                <td>@(totalReads > 0 ? $"{totalReadTime / totalReads:F2} ms" : "N/A")</td>
                            </tr>
                        </tbody>
                    </table>
                    <button class="btn btn-warning btn-sm" @onclick="ResetMetrics">Reset Metrics</button>
                    <button class="btn btn-secondary btn-sm ms-2" @onclick="CheckMemory">Check Memory</button>

                    @if (memoryInfo != null)
                    {
                        <div class="mt-3 p-2 border rounded">
                            <h6>Memory Profile</h6>
                            <small class="d-block">Heap Used: @FormatBytes((long)(memoryInfo.UsedHeapSize ?? 0))</small>
                            <small class="d-block">Heap Limit: @FormatBytes((long)(memoryInfo.HeapLimit ?? 0))</small>
                            <small class="d-block @(memoryInfo.IsCritical ? "text-danger" : memoryInfo.IsHighPressure ? "text-warning" : "text-success")">
                                Usage: @($"{memoryInfo.UsagePercent:F1}")%
                            </small>
                            @if (memoryInfo.LeakDetected)
                            {
                                <small class="d-block text-danger">⚠️ Memory leak detected!</small>
                            }
                        </div>
                    }
                </div>
            </div>
        </div>

        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>Operation Log</h5>
                </div>
                <div class="card-body" style="height: 300px; overflow-y: auto;">
                    <ul class="list-unstyled small">
                        @foreach (var log in operationLogs.TakeLast(20).Reverse())
                        {
                            <li class="@GetLogClass(log.Type)">
                                <span class="badge bg-secondary">@log.Timestamp.ToString("HH:mm:ss.fff")</span>
                                @log.Message
                            </li>
                        }
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="row mt-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5>Stress Testing</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <label>Number of Files:</label>
                            <input type="number" class="form-control" @bind="stressFileCount" min="1" max="100" />
                        </div>
                        <div class="col-md-4">
                            <label>File Size (KB each):</label>
                            <input type="number" class="form-control" @bind="stressFileSizeKb" min="1" max="1024" />
                        </div>
                        <div class="col-md-4">
                            <label>&nbsp;</label><br />
                            <button class="btn btn-danger" @onclick="RunStressTest" disabled="@isStressTesting">
                                @if (isStressTesting)
                                {
                                    <span class="spinner-border spinner-border-sm me-2"></span>
                                }
                                Run Stress Test
                            </button>
                        </div>
                    </div>
                    @if (stressProgress > 0)
                    {
                        <div class="progress mt-3">
                            <div class="progress-bar" role="progressbar" style="width: @(stressProgress)%">
                                @stressProgress%
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private string writePath = "/test/sample.txt";
    private string readPath = "/test/sample.txt";
    private int fileSizeKb = 256; // Default to 256KB (our buffer size)
    private string contentType = "text";
    private bool verifyContent = false;

    private bool isWriting = false;
    private bool isReading = false;
    private bool isListing = false;
    private bool isStressTesting = false;

    // Metrics
    private int totalWrites = 0;
    private int totalReads = 0;
    private long totalBytesWritten = 0;
    private long totalBytesRead = 0;
    private double totalWriteTime = 0;
    private double totalReadTime = 0;

    // Stress test
    private int stressFileCount = 10;
    private int stressFileSizeKb = 256;
    private int stressProgress = 0;

    // Memory profiling
    private IJSObjectReference? memoryProfilerModule;
    private MemoryInfo? memoryInfo;

    // Logging
    private List<OperationLog> operationLogs = new();

    private class OperationLog
    {
        public DateTime Timestamp { get; set; }
        public string Type { get; set; } = "";
        public string Message { get; set; } = "";
    }

    private class MemoryInfo
    {
        public double? UsedHeapSize { get; set; }
        public double? HeapLimit { get; set; }
        public double UsagePercent { get; set; }
        public bool IsHighPressure { get; set; }
        public bool IsCritical { get; set; }
        public bool LeakDetected { get; set; }
        public double? GrowthRateMB { get; set; }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Load mock IPFS MFS for testing
                await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./js/modules/ipfs-mfs-mock.js");

                memoryProfilerModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./js/memory-profiler.js");

                // Set initial baseline
                await memoryProfilerModule.InvokeVoidAsync("memoryProfiler.setBaseline");
                await CheckMemory();
            }
            catch (Exception ex)
            {
                LogOperation("warning", $"Memory profiler not available: {ex.Message}");
            }
        }
    }

    private async Task WriteFile()
    {
        isWriting = true;
        var sw = Stopwatch.StartNew();

        try
        {
            // Capture memory before operation
            await CaptureMemorySnapshot("before-write");

            var bytes = GenerateContent(fileSizeKb * 1024);

            using var memoryStream = new MemoryStream(bytes);
            var cid = await IpfsService.WriteFileAsync(writePath, memoryStream);

            sw.Stop();
            totalWrites++;
            totalBytesWritten += bytes.Length;
            totalWriteTime += sw.ElapsedMilliseconds;

            // Capture memory after operation
            await CaptureMemorySnapshot("after-write");

            LogOperation("success", $"Wrote {FormatBytes(bytes.Length)} to {writePath} in {sw.ElapsedMilliseconds}ms");
        }
        catch (Exception ex)
        {
            sw.Stop();
            LogOperation("error", $"Write failed: {ex.Message}");
        }
        finally
        {
            isWriting = false;
            StateHasChanged();
        }
    }

    private async Task ReadFile()
    {
        isReading = true;
        var sw = Stopwatch.StartNew();

        try
        {
            // Capture memory before operation
            await CaptureMemorySnapshot("before-read");

            using var stream = await IpfsService.ReadFileAsync(readPath);
            var buffer = new byte[256 * 1024]; // 256KB buffer as per spec
            var totalRead = 0;
            int bytesRead;

            while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
            {
                totalRead += bytesRead;

                if (verifyContent)
                {
                    // Verify first few bytes for pattern validation
                    // This adds overhead but helps validate data integrity
                }
            }

            sw.Stop();
            totalReads++;
            totalBytesRead += totalRead;
            totalReadTime += sw.ElapsedMilliseconds;

            // Capture memory after operation
            await CaptureMemorySnapshot("after-read");

            LogOperation("success", $"Read {FormatBytes(totalRead)} from {readPath} in {sw.ElapsedMilliseconds}ms");
        }
        catch (Exception ex)
        {
            sw.Stop();
            LogOperation("error", $"Read failed: {ex.Message}");
        }
        finally
        {
            isReading = false;
            StateHasChanged();
        }
    }

    private async Task ListFiles()
    {
        isListing = true;

        try
        {
            var directory = System.IO.Path.GetDirectoryName(readPath) ?? "/";
            var files = new List<IpfsFileEntry>();
            await foreach (var file in IpfsService.ListDirectoryAsync(directory))
            {
                files.Add(file);
            }

            LogOperation("info", $"Found {files.Count} files in {directory}");

            foreach (var file in files.Take(10)) // Limit display
            {
                LogOperation("info", $"  - {file.Name} ({FormatBytes(file.Size)})");
            }
        }
        catch (Exception ex)
        {
            LogOperation("error", $"List failed: {ex.Message}");
        }
        finally
        {
            isListing = false;
            StateHasChanged();
        }
    }

    private async Task RunStressTest()
    {
        isStressTesting = true;
        stressProgress = 0;

        LogOperation("info", $"Starting stress test: {stressFileCount} files of {stressFileSizeKb}KB each");

        try
        {
            // Set baseline before stress test
            if (memoryProfilerModule != null)
            {
                await memoryProfilerModule.InvokeVoidAsync("memoryProfiler.setBaseline");
            }

            var bytes = GenerateContent(stressFileSizeKb * 1024);

            for (int i = 0; i < stressFileCount; i++)
            {
                var path = $"/stress-test/file_{i:D4}.dat";

                // Write
                using (var memStream = new MemoryStream(bytes))
                {
                    await IpfsService.WriteFileAsync(path, memStream);
                }

                // Read back immediately
                using (var readStream = await IpfsService.ReadFileAsync(path))
                {
                    var buffer = new byte[256 * 1024];
                    while (await readStream.ReadAsync(buffer, 0, buffer.Length) > 0) { }
                }

                stressProgress = (int)((i + 1) * 100.0 / stressFileCount);

                // Check memory every 5 iterations
                if (i % 5 == 0)
                {
                    await CheckMemory();

                    // Check for critical memory pressure
                    if (memoryInfo?.IsCritical == true)
                    {
                        LogOperation("error", $"Critical memory pressure detected at iteration {i + 1}. Stopping stress test.");
                        break;
                    }
                }

                StateHasChanged();

                // Small delay to prevent UI freezing
                await Task.Delay(10);
            }

            // Final memory check after stress test
            await CheckMemory();

            if (memoryInfo?.LeakDetected == true)
            {
                LogOperation("warning", $"Memory leak detected during stress test. Growth rate: {memoryInfo.GrowthRateMB:F2} MB/s");
            }

            LogOperation("success", $"Stress test completed: {stressFileCount} files processed");
        }
        catch (Exception ex)
        {
            LogOperation("error", $"Stress test failed: {ex.Message}");
        }
        finally
        {
            isStressTesting = false;
            stressProgress = 0;
            StateHasChanged();
        }
    }

    private async Task CheckMemory()
    {
        try
        {
            if (memoryProfilerModule == null)
            {
                LogOperation("warning", "Memory profiler not initialized");
                return;
            }

            // Get comprehensive memory report as JsonElement
            var reportJson = await memoryProfilerModule.InvokeAsync<System.Text.Json.JsonElement>("memoryProfiler.getMemoryReport");

            if (reportJson.ValueKind != System.Text.Json.JsonValueKind.Undefined && reportJson.ValueKind != System.Text.Json.JsonValueKind.Null)
            {
                var current = reportJson.GetProperty("current");
                var leakDetection = reportJson.GetProperty("leakDetection");

                memoryInfo = new MemoryInfo
                {
                    UsedHeapSize = current.TryGetProperty("usedJSHeapSize", out var usedHeap) ? usedHeap.GetDouble() : null,
                    HeapLimit = reportJson.TryGetProperty("deviceLimitMB", out var limitMb) ? limitMb.GetDouble() * 1024 * 1024 : null,
                    UsagePercent = current.TryGetProperty("limitUsagePercent", out var usagePercent) ? usagePercent.GetDouble() : 0,
                    IsHighPressure = current.TryGetProperty("isHighPressure", out var highPressure) ? highPressure.GetBoolean() : false,
                    IsCritical = current.TryGetProperty("isCritical", out var critical) ? critical.GetBoolean() : false,
                    LeakDetected = leakDetection.TryGetProperty("detected", out var detected) ? detected.GetBoolean() : false,
                    GrowthRateMB = leakDetection.TryGetProperty("averageGrowthMB", out var growth) ? growth.GetDouble() : null
                };

                LogOperation("info", $"Memory: {FormatBytes((long)(memoryInfo.UsedHeapSize ?? 0))} / {FormatBytes((long)(memoryInfo.HeapLimit ?? 0))} ({memoryInfo.UsagePercent:F1}%)");

                if (memoryInfo.LeakDetected)
                {
                    LogOperation("warning", $"Memory leak detected: {memoryInfo.GrowthRateMB:F2} MB average growth");
                }

                if (memoryInfo.IsCritical)
                {
                    LogOperation("error", "CRITICAL: Memory usage above 95% of device limit");
                }
                else if (memoryInfo.IsHighPressure)
                {
                    LogOperation("warning", "WARNING: Memory usage above 80% of device limit");
                }

                // Log recommendations
                if (reportJson.TryGetProperty("recommendations", out var recommendationsJson) &&
                    recommendationsJson.ValueKind == System.Text.Json.JsonValueKind.Array)
                {
                    foreach (var rec in recommendationsJson.EnumerateArray())
                    {
                        if (rec.ValueKind == System.Text.Json.JsonValueKind.String)
                        {
                            LogOperation("info", $"Recommendation: {rec.GetString()}");
                        }
                    }
                }
            }

            // Force garbage collection hint
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();

            var managedMemory = GC.GetTotalMemory(false);
            LogOperation("info", $"Managed memory: {FormatBytes(managedMemory)}");

            StateHasChanged();
        }
        catch (Exception ex)
        {
            LogOperation("error", $"Memory check failed: {ex.Message}");
        }
    }

    private async Task CaptureMemorySnapshot(string label)
    {
        if (memoryProfilerModule != null)
        {
            try
            {
                var snapshot = await memoryProfilerModule.InvokeAsync<dynamic>($"memoryProfiler.captureSnapshot", label);

                if (snapshot?.supported == false)
                {
                    // Memory API not supported in this browser
                    return;
                }

                var usedMB = (double)(snapshot?.usedJSHeapSize ?? 0) / (1024 * 1024);
                var limitPercent = (double)(snapshot?.limitUsagePercent ?? 0);

                if (snapshot?.isCritical == true)
                {
                    LogOperation("error", $"[{label}] Critical memory: {usedMB:F1}MB ({limitPercent:F1}%)");
                }
                else if (snapshot?.isHighPressure == true)
                {
                    LogOperation("warning", $"[{label}] High memory: {usedMB:F1}MB ({limitPercent:F1}%)");
                }
            }
            catch
            {
                // Silently fail if memory profiling not available
            }
        }
    }

    private void ResetMetrics()
    {
        totalWrites = 0;
        totalReads = 0;
        totalBytesWritten = 0;
        totalBytesRead = 0;
        totalWriteTime = 0;
        totalReadTime = 0;
        operationLogs.Clear();
        LogOperation("info", "Metrics reset");
    }

    private byte[] GenerateContent(int size)
    {
        var bytes = new byte[size];

        switch (contentType)
        {
            case "random":
                new Random().NextBytes(bytes);
                break;

            case "json":
                var json = "{ \"data\": \"" + new string('x', Math.Min(size - 20, 1000)) + "\" }";
                var jsonBytes = Encoding.UTF8.GetBytes(json);
                Array.Copy(jsonBytes, bytes, Math.Min(jsonBytes.Length, size));
                break;

            case "text":
            default:
                var pattern = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                for (int i = 0; i < size; i++)
                {
                    bytes[i] = (byte)pattern[i % pattern.Length];
                }
                break;
        }

        return bytes;
    }

    private void LogOperation(string type, string message)
    {
        operationLogs.Add(new OperationLog
        {
            Timestamp = DateTime.Now,
            Type = type,
            Message = message
        });

        // Keep only last 100 logs
        if (operationLogs.Count > 100)
        {
            operationLogs.RemoveRange(0, operationLogs.Count - 100);
        }
    }

    private string GetLogClass(string type)
    {
        return type switch
        {
            "error" => "text-danger",
            "success" => "text-success",
            "warning" => "text-warning",
            "info" => "text-info",
            _ => ""
        };
    }

    private string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;

        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }

        return $"{len:F2} {sizes[order]}";
    }

    public async ValueTask DisposeAsync()
    {
        if (memoryProfilerModule != null)
        {
            try
            {
                await memoryProfilerModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}