@namespace NoLock.Social.Components.Camera
@using NoLock.Social.Core.Camera.Interfaces
@using NoLock.Social.Core.Camera.Models
@using NoLock.Social.Core.Accessibility.Interfaces
@implements IAsyncDisposable

@inject ICameraService CameraService
@inject IVoiceCommandService VoiceCommandService
@inject IAnnouncementService AnnouncementService

<style>
    @keyframes flash {
        0% { opacity: 0; }
        50% { opacity: 0.8; }
        100% { opacity: 0; }
    }
</style>

<div class="camera-preview-container" role="region" aria-label="Camera interface for document capture" data-accessibility-component="camera-preview">
    <!-- Offline Status Indicator -->
    <OfflineStatusIndicator />
    
    <!-- Voice Command Status Indicator -->
    @if (_isVoiceCommandEnabled && _isVoiceCommandListening)
    {
        <div class="voice-command-indicator position-absolute top-0 end-0 m-3 p-2 bg-success text-white rounded shadow"
             role="status"
             aria-live="polite"
             aria-label="Voice commands active for camera preview"
             style="z-index: 20;">
            <i class="bi bi-mic-fill me-2" aria-hidden="true"></i>
            Voice Active
        </div>
    }
    
    <!-- Screen Reader Announcements -->
    <div aria-live="polite" aria-atomic="true" id="cameraAnnouncements" class="visually-hidden">
        @if (!string.IsNullOrEmpty(_screenReaderMessage))
        {
            <span>@_screenReaderMessage</span>
        }
    </div>
    
    @if (IsLoading)
    {
        <div class="d-flex justify-content-center align-items-center p-4">
            <div class="spinner-border text-primary" role="status" aria-describedby="loadingMessage">
                <span class="visually-hidden" id="loadingMessage">Loading camera interface, please wait</span>
            </div>
        </div>
    }
    else if (!string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="alert alert-danger" role="alert" aria-describedby="errorDescription">
            <i class="bi bi-exclamation-triangle-fill me-2" aria-hidden="true"></i>
            <span id="errorDescription">Camera error: @ErrorMessage</span>
        </div>
    }
    else
    {
        <div class="position-relative">
            <video class="camera-video" 
                   autoplay 
                   muted 
                   playsinline
                   src="@CurrentStream?.StreamUrl"
                   style="@(HasCapturedImage ? "display: none;" : "")"
                   aria-label="Live camera feed showing document capture area">
            </video>
            <ViewfinderOverlay 
                DocumentType="DocumentType.Generic"
                IsDetecting="false"
                IsValid="false" />
            
            <!-- Camera Controls Overlay -->
            <CameraControls ShowControls="@(!HasCapturedImage && !IsCapturing)" />
            
            <!-- Captured Image Preview -->
            @if (HasCapturedImage)
            {
                <div class="captured-image-preview position-absolute top-0 start-0 w-100 h-100 bg-dark d-flex flex-column">
                    <div class="flex-grow-1 d-flex justify-content-center align-items-center p-3">
                        <img src="@CapturedImage.DataUrl" 
                             alt="Captured document image, @CapturedImage.Width by @CapturedImage.Height pixels, taken at @CapturedImage.Timestamp.ToString("HH:mm:ss")" 
                             class="img-fluid rounded shadow-lg"
                             style="max-height: 100%; max-width: 100%; object-fit: contain;"
                             role="img" />
                    </div>
                    
                    <!-- Image Metadata -->
                    <div class="bg-dark bg-opacity-75 text-white p-2 small" role="status" aria-label="Image information">
                        <div class="d-flex justify-content-between align-items-center">
                            <span aria-label="Image dimensions">
                                <i class="bi bi-image me-1" aria-hidden="true"></i>
                                @CapturedImage.Width x @CapturedImage.Height
                            </span>
                            <span aria-label="Capture time">
                                <i class="bi bi-clock me-1" aria-hidden="true"></i>
                                @CapturedImage.Timestamp.ToString("HH:mm:ss")
                            </span>
                        </div>
                    </div>
                    
                    <!-- Image Quality Feedback -->
                    <ImageQualityFeedback QualityResult="@ImageQualityResult" />
                    
                    <!-- Action Buttons -->
                    <div class="d-flex justify-content-center gap-2 p-3 bg-dark bg-opacity-75 flex-wrap">
                        <button type="button" 
                                class="btn btn-secondary btn-lg px-4"
                                aria-label="Retake image - discard current capture and return to camera"
                                @onclick="RetakeImage">
                            <i class="bi bi-arrow-clockwise me-2" aria-hidden="true"></i>
                            Retake
                        </button>
                        <button type="button" 
                                class="btn btn-success btn-lg px-4"
                                aria-label="Accept image - confirm and proceed with this capture"
                                @onclick="AcceptImage">
                            <i class="bi bi-check-lg me-2" aria-hidden="true"></i>
                            Accept
                        </button>
                    </div>
                </div>
            }
            
            <!-- Capture Button -->
            <div class="position-absolute bottom-0 start-50 translate-middle-x mb-3">
                <button type="button" 
                        class="btn btn-primary btn-lg rounded-circle p-3"
                        disabled="@(!IsCameraReady || IsCapturing)"
                        aria-label="@(IsCapturing ? "Capturing image, please wait" : "Capture document image")"
                        aria-describedby="captureButtonHelp"
                        @onclick="CaptureImage">
                    @if (IsCapturing)
                    {
                        <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true">
                            <span class="visually-hidden">Capturing image</span>
                        </div>
                    }
                    else
                    {
                        <i class="bi bi-camera fs-4" aria-hidden="true"></i>
                    }
                </button>
                <div id="captureButtonHelp" class="visually-hidden">
                    Press to take a photo of your document. Ensure document is well-lit and within the frame guides.
                </div>
            </div>
            
            <!-- Auto-Capture Countdown Overlay -->
            @if (IsCountingDown)
            {
                <div class="position-absolute top-50 start-50 translate-middle" style="z-index: 15;" role="timer" aria-live="assertive" aria-atomic="true">
                    <div class="bg-primary text-white rounded-circle d-flex justify-content-center align-items-center"
                         style="width: 120px; height: 120px; font-size: 3rem; font-weight: bold; border: 4px solid white; box-shadow: 0 0 20px rgba(0,0,0,0.5);"
                         aria-label="Auto-capture countdown">
                        @AutoCaptureCountdown
                    </div>
                    <div class="text-center mt-2">
                        <small class="bg-dark text-white px-2 py-1 rounded" aria-hidden="true">Auto-capture in progress</small>
                    </div>
                </div>
            }
            
            <!-- Flash Effect Overlay -->
            @if (IsCapturing)
            {
                <div class="flash-overlay position-absolute top-0 start-0 w-100 h-100 bg-white" 
                     style="opacity: 0.8; z-index: 10; animation: flash 0.3s ease-out;"></div>
            }
        </div>
    }
</div>

@code {
    [Parameter] public EventCallback<CapturedImage> OnImageAccepted { get; set; }
    [Parameter] public bool EnableAutoCapture { get; set; }
    [Parameter] public string? SessionId { get; set; }
    [Parameter] public EventCallback<CapturedImage> OnPageAdded { get; set; }
    [Parameter] public bool EnableVoiceCommands { get; set; } = true;
    
    private bool IsLoading = true;
    private string? ErrorMessage;
    private CameraStream? CurrentStream;
    private CapturedImage? CapturedImage;
    private bool IsCapturing;
    private bool IsDocumentDetected;
    private int AutoCaptureCountdown;
    private System.Threading.Timer? AutoCaptureTimer;
    private ImageQualityResult? ImageQualityResult;
    
    private bool IsCameraReady => !IsLoading && string.IsNullOrEmpty(ErrorMessage) && CurrentStream != null;
    private bool HasCapturedImage => CapturedImage != null;
    private bool IsCountingDown => EnableAutoCapture && IsDocumentDetected && AutoCaptureCountdown > 0;
    private string _screenReaderMessage = "";
    
    // Voice command state
    private bool _isVoiceCommandEnabled;
    private bool _isVoiceCommandListening;
    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Check camera permissions first
            var hasPermission = await CameraService.CheckPermissionsAsync();
            if (!hasPermission)
            {
                ErrorMessage = "Camera permission denied. Please enable camera access.";
                IsLoading = false;
                await AnnounceToScreenReader("Camera permission denied. Please enable camera access in your browser settings.");
                return;
            }
            
            // Start the camera stream
            CurrentStream = await CameraService.StartStreamAsync(new CameraOptions
            {
                VideoDeviceId = null, // Use default camera
                Width = 1280,
                Height = 720,
                FacingMode = CameraFacingMode.User
            });
            
            IsLoading = false;
            await AnnounceToScreenReader("Camera started successfully. Ready to capture documents.");
            
            // Initialize voice commands after camera is ready
            if (EnableVoiceCommands)
            {
                await InitializeVoiceCommandsAsync();
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to start camera: {ex.Message}";
            IsLoading = false;
            await AnnounceToScreenReader($"Camera failed to start: {ex.Message}");
            
            // Don't initialize voice commands if camera failed
            _isVoiceCommandEnabled = false;
            _isVoiceCommandListening = false;
        }
    }
    
    private async Task CaptureImage()
    {
        try
        {
            if (!IsCameraReady || IsCapturing)
                return;
                
            // Set capturing state and show visual feedback
            IsCapturing = true;
            StateHasChanged();
            
            // Small delay to show the flash effect
            await Task.Delay(100);
            
            // Capture the image from the current stream
            CapturedImage = await CameraService.CaptureImageAsync();
            await AnnounceToScreenReader("Image captured successfully. Review the image and choose to retake or accept.");
            
            // Analyze image quality after successful capture
            try
            {
                ImageQualityResult = await CameraService.ValidateImageQualityAsync(CapturedImage);
                if (ImageQualityResult != null)
                {
                    var qualityMessage = ImageQualityResult.IsAcceptable ? "Image quality is good" : "Image quality needs improvement";
                    await AnnounceToScreenReader(qualityMessage);
                }
            }
            catch (Exception qualityEx)
            {
                // Quality analysis failed, but capture succeeded - log and continue
                Console.Error.WriteLine($"Image quality analysis failed: {qualityEx.Message}");
                ImageQualityResult = null;
            }
            
            // Brief delay for flash completion
            await Task.Delay(200);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to capture image: {ex.Message}";
            await AnnounceToScreenReader($"Image capture failed: {ex.Message}");
        }
        finally
        {
            // Reset capturing state
            IsCapturing = false;
            StateHasChanged();
        }
    }
    
    private async Task RetakeImage()
    {
        // Clear the captured image and quality result to return to camera view
        CapturedImage = null;
        ImageQualityResult = null;
        await AnnounceToScreenReader("Returned to camera view. Ready to capture a new image.");
        StateHasChanged();
    }
    
    private async Task AcceptImage()
    {
        if (CapturedImage == null)
            return;
            
        try
        {
            // If SessionId is provided, add the page to the session
            if (!string.IsNullOrEmpty(SessionId))
            {
                await CameraService.AddPageToSessionAsync(SessionId, CapturedImage);
                
                // Notify that a page was added to the session
                if (OnPageAdded.HasDelegate)
                {
                    await OnPageAdded.InvokeAsync(CapturedImage);
                }
            }
            
            // Always invoke the original callback for backward compatibility
            if (OnImageAccepted.HasDelegate)
            {
                await OnImageAccepted.InvokeAsync(CapturedImage);
            }
            
            await AnnounceToScreenReader("Image accepted and processed successfully.");
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to add page to session: {ex.Message}";
            await AnnounceToScreenReader($"Failed to add page to session: {ex.Message}");
            StateHasChanged();
        }
    }
    
    private async Task StartAutoCapture()
    {
        if (!EnableAutoCapture || IsCapturing || HasCapturedImage)
            return;
            
        IsDocumentDetected = true;
        AutoCaptureCountdown = 3;
        await AnnounceToScreenReader("Document detected. Auto-capture starting in 3 seconds.");
        
        // Also announce via the proper announcement service for better coordination
        if (AnnouncementService != null)
        {
            await AnnouncementService.AnnounceAssertiveAsync(
                "Document detected. Auto-capture starting in 3 seconds.", 
                AnnouncementCategory.CameraOperation);
        }
        
        StateHasChanged();
        
        AutoCaptureTimer?.Dispose();
        AutoCaptureTimer = new System.Threading.Timer(async _ =>
        {
            await InvokeAsync(async () =>
            {
                AutoCaptureCountdown--;
                
                if (AutoCaptureCountdown <= 0)
                {
                    AutoCaptureTimer?.Dispose();
                    AutoCaptureTimer = null;
                    IsDocumentDetected = false;
                    
                    if (IsCameraReady && !IsCapturing)
                    {
                        await CaptureImage();
                    }
                }
                
                StateHasChanged();
            });
        }, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }
    
    private async Task CancelAutoCapture()
    {
        AutoCaptureTimer?.Dispose();
        AutoCaptureTimer = null;
        IsDocumentDetected = false;
        AutoCaptureCountdown = 0;
        await AnnounceToScreenReader("Auto-capture cancelled. Document no longer detected.");
        
        // Also announce via the proper announcement service for better coordination
        if (AnnouncementService != null)
        {
            await AnnouncementService.AnnouncePoliteAsync(
                "Auto-capture cancelled. Document no longer detected.", 
                AnnouncementCategory.CameraOperation);
        }
        
        StateHasChanged();
    }
    
    // Simulate document detection for demo - in real implementation this would be triggered by document detection logic
    private async Task SimulateDocumentDetection(bool detected)
    {
        if (detected && !IsDocumentDetected && EnableAutoCapture)
        {
            await StartAutoCapture();
        }
        else if (!detected && IsDocumentDetected)
        {
            await CancelAutoCapture();
        }
    }
    
    private async Task AnnounceToScreenReader(string message)
    {
        if (string.IsNullOrEmpty(message)) return;
        
        _screenReaderMessage = message;
        StateHasChanged();
        
        // Clear the message after a brief delay so it can be announced again if needed
        await Task.Delay(100);
        _screenReaderMessage = "";
    }
    
    // Voice command initialization and handling
    private async Task InitializeVoiceCommandsAsync()
    {
        try
        {
            // Check if speech recognition is supported
            _isVoiceCommandEnabled = await VoiceCommandService.IsSpeechRecognitionSupportedAsync();
            
            if (!_isVoiceCommandEnabled)
            {
                return;
            }
            
            // Subscribe to voice command events
            VoiceCommandService.OnCommandRecognized += OnVoiceCommandRecognized;
            VoiceCommandService.OnSpeechError += OnVoiceCommandError;
            
            // Configure voice commands for camera preview operations
            var commands = new Dictionary<string, Func<Task>>
            {
                // Capture commands
                ["capture"] = async () => {
                    if (IsCameraReady && !IsCapturing && !HasCapturedImage)
                        await CaptureImage();
                },
                ["take photo"] = async () => {
                    if (IsCameraReady && !IsCapturing && !HasCapturedImage)
                        await CaptureImage();
                },
                ["snap"] = async () => {
                    if (IsCameraReady && !IsCapturing && !HasCapturedImage)
                        await CaptureImage();
                },
                
                // Camera stream commands
                ["start camera"] = async () => {
                    if (string.IsNullOrEmpty(ErrorMessage) && CurrentStream == null)
                        await StartCameraStreamAsync();
                },
                ["begin scanning"] = async () => {
                    if (string.IsNullOrEmpty(ErrorMessage) && CurrentStream == null)
                        await StartCameraStreamAsync();
                },
                ["stop camera"] = async () => {
                    if (CurrentStream != null)
                        await StopCameraStreamAsync();
                },
                ["end scanning"] = async () => {
                    if (CurrentStream != null)
                        await StopCameraStreamAsync();
                },
                
                // Image review commands
                ["retake"] = async () => {
                    if (HasCapturedImage)
                        await RetakeImage();
                },
                ["accept"] = async () => {
                    if (HasCapturedImage)
                        await AcceptImage();
                }
            };
            
            await VoiceCommandService.SetCommandsAsync(commands);
            
            // Start listening for voice commands
            await VoiceCommandService.StartListeningAsync();
            _isVoiceCommandListening = true;
            
            await AnnounceToScreenReader("Voice commands enabled for camera preview");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error initializing voice commands: {ex.Message}");
            _isVoiceCommandEnabled = false;
            _isVoiceCommandListening = false;
        }
    }
    
    private async Task StartCameraStreamAsync()
    {
        try
        {
            if (CurrentStream != null) return;
            
            IsLoading = true;
            StateHasChanged();
            
            CurrentStream = await CameraService.StartStreamAsync(new CameraOptions
            {
                VideoDeviceId = null,
                Width = 1280,
                Height = 720,
                FacingMode = CameraFacingMode.User
            });
            
            IsLoading = false;
            ErrorMessage = "";
            await AnnounceToScreenReader("Camera stream started via voice command");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to start camera: {ex.Message}";
            IsLoading = false;
            await AnnounceToScreenReader($"Camera start failed: {ex.Message}");
            StateHasChanged();
        }
    }
    
    private async Task StopCameraStreamAsync()
    {
        try
        {
            if (CurrentStream == null) return;
            
            await CameraService.StopStreamAsync();
            CurrentStream = null;
            
            await AnnounceToScreenReader("Camera stream stopped via voice command");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error stopping camera stream: {ex.Message}");
            await AnnounceToScreenReader($"Camera stop failed: {ex.Message}");
        }
    }
    
    private async void OnVoiceCommandRecognized(object? sender, VoiceCommandEventArgs e)
    {
        try
        {
            await InvokeAsync(async () =>
            {
                await AnnouncementService.AnnouncePoliteAsync(
                    $"Voice command recognized: {e.MatchedCommand}", 
                    AnnouncementCategory.VoiceCommand);
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error handling voice command recognition: {ex.Message}");
        }
    }
    
    private async void OnVoiceCommandError(object? sender, SpeechErrorEventArgs e)
    {
        try
        {
            await InvokeAsync(async () =>
            {
                await AnnouncementService.AnnounceAssertiveAsync(
                    $"Voice command error: {e.ErrorMessage}", 
                    AnnouncementCategory.Error);
                
                // Try to restart listening if it was stopped due to error
                if (_isVoiceCommandEnabled && !await VoiceCommandService.IsListeningAsync())
                {
                    try
                    {
                        await VoiceCommandService.StartListeningAsync();
                        _isVoiceCommandListening = true;
                        StateHasChanged();
                    }
                    catch (Exception restartEx)
                    {
                        Console.Error.WriteLine($"Failed to restart voice command listening: {restartEx.Message}");
                        _isVoiceCommandListening = false;
                        StateHasChanged();
                    }
                }
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error handling voice command error event: {ex.Message}");
        }
    }
    
    public async ValueTask DisposeAsync()
    {
        try
        {
            // Clean up voice command service
            if (_isVoiceCommandEnabled)
            {
                try
                {
                    VoiceCommandService.OnCommandRecognized -= OnVoiceCommandRecognized;
                    VoiceCommandService.OnSpeechError -= OnVoiceCommandError;
                    
                    if (_isVoiceCommandListening)
                    {
                        await VoiceCommandService.StopListeningAsync();
                    }
                }
                catch (Exception voiceEx)
                {
                    Console.Error.WriteLine($"Error disposing voice command service: {voiceEx.Message}");
                }
            }
            
            // Clean up auto-capture timer
            AutoCaptureTimer?.Dispose();
            AutoCaptureTimer = null;
            
            // Check if we have an active stream to dispose
            if (CurrentStream != null)
            {
                try
                {
                    // Stop the camera stream
                    await CameraService.StopStreamAsync();
                    
                    // Clear the reference
                    CurrentStream = null;
                }
                catch (Exception ex)
                {
                    // Log error but don't throw during disposal
                    // Disposal should complete even if there's an error
                    Console.Error.WriteLine($"Error disposing camera stream: {ex.Message}");
                }
            }
        }
        catch (Exception ex)
        {
            // Log error but don't throw during disposal
            Console.Error.WriteLine($"Error during CameraPreview disposal: {ex.Message}");
        }
    }
}