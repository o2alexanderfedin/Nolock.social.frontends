---
description: Automated git flow with intelligent branch detection, commit, release, and push - uses git-flow-automation agent
allowed-tools: Task, Bash, Read, Grep, Glob, LS
argument-hint: [optional: commit message or feature name]
---

## Intent: Deliver Your Completed Work

This command helps you properly version and release your completed work following git flow best practices. It automates the entire process from analyzing changes to creating releases, ensuring your work is properly tracked and versioned.

---

Launch the git-flow-automation agent to execute a complete automated git flow workflow for solo development (no PRs).

## AGENT TASK:
Use your git flow expertise to automate the entire workflow:

### 0. PRE-FLOW SYNCHRONIZATION
- Pull latest changes from both main and develop branches
- Ensure develop is up-to-date with main before starting any flow
- Check for potential conflicts between main and develop
- If develop is behind main, merge main into develop first
- Abort if there are uncommitted changes or merge conflicts

### 1. ANALYZE CHANGES
- Run `git status` to see what changed
- Run `git diff --stat` for summary
- Run `git diff` to review actual changes
- Determine change type: feature, fix, refactor, docs, test, chore
- Auto-generate appropriate branch name based on changes

### 2. SMART BRANCH SELECTION
- **feature/** - New functionality, enhancements
- **hotfix/** - Critical production fixes (from main)
- **bugfix/** - Non-critical bug fixes (from develop)
- Switch to correct base branch before starting

### 3. EXECUTE GIT FLOW
```bash
# Start appropriate flow
git flow <type> start <auto-generated-name>

# Stage all changes  
git add -A

# Commit with smart message
# Format: <type>: <description>
# Examples: 
#   feat: add user authentication
#   fix: resolve memory leak in storage
#   refactor: simplify metadata structure
git commit -m "<generated-message>"

# Finish flow non-interactively
git flow <type> finish -F <name>
```

### 4. INTELLIGENT VERSION BUMP
```bash
# Get current version
CURRENT=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")

# Smart version increment based on changes:
# - Breaking changes (major): 1.0.0 ‚Üí 2.0.0
# - Features (minor): 1.0.0 ‚Üí 1.1.0  
# - Fixes/other (patch): 1.0.0 ‚Üí 1.0.1

# Create release
git flow release start <new-version>
git flow release finish -F -m "Release <new-version>" <new-version>
```

### 5. PUSH EVERYTHING
```bash
git push origin main
git push origin develop  
git push --tags
```

### 6. FINAL VERIFICATION
```bash
# Check branch synchronization
git rev-list --left-right --count main...develop
# Output: 0    0 means fully synchronized

# Verify all merges were successful
git log --oneline -n 5 main
git log --oneline -n 5 develop

# Check for any divergence
DIVERGED=$(git rev-list --left-right --count main...develop | awk '{if ($1 != 0 || $2 != 0) print "DIVERGED"}')
if [ "$DIVERGED" = "DIVERGED" ]; then
    echo "‚ö†Ô∏è WARNING: Branches have diverged!"
    git rev-list --left-right --count main...develop
fi

# Confirm no uncommitted changes remain
git status --porcelain
# Empty output means working tree is clean

# Verify tags were created and pushed
git tag --list --sort=-version:refname | head -3
git ls-remote --tags origin | tail -3

# Display new version created
echo "New version: $(git describe --tags --abbrev=0)"

# Show summary of operations
echo "Main branch: $(git rev-parse --short main)"
echo "Develop branch: $(git rev-parse --short develop)"
echo "Latest tag: $(git describe --tags --abbrev=0)"
```

## AGENT INSTRUCTIONS:
- You are the git-flow-automation expert - use your knowledge
- Auto-detect everything - don't ask questions
- Generate descriptive branch names from actual changes
- Create meaningful commit messages from code changes
- Pick correct version bump based on change type
- Use `-F` flag for non-interactive mode
- If user provided "$ARGUMENTS", incorporate into commit message

## CONFLICT RECOVERY STRATEGY

### If Merge Conflicts Occur:

1. **IMMEDIATE ASSESSMENT**
```bash
# Check current state
git status
git branch --show-current
# Identify which operation failed
git flow config | grep "branch\."
```

2. **SAFE ABORT PROCEDURE**
```bash
# For feature/bugfix conflicts
git flow feature abort <name> 2>/dev/null || git flow bugfix abort <name> 2>/dev/null

# For release conflicts  
git flow release abort <version> 2>/dev/null

# For hotfix conflicts
git flow hotfix abort <name> 2>/dev/null

# Reset to clean state if needed
git reset --hard HEAD
git checkout develop
```

3. **MANUAL CONFLICT RESOLUTION**
```bash
# If conflicts must be resolved:
# 1. Stay in conflict state
git status --short | grep "^UU"  # List conflicted files

# 2. Resolve each file
# Edit files to resolve conflicts, then:
git add <resolved-file>

# 3. Continue the flow operation
git flow <type> finish <name>  # Will retry the merge
```

4. **RECOVERY VERIFICATION**
```bash
# After recovery, ensure everything is merged:
# Check no flow branches remain
git branch | grep -E "^  (feature|bugfix|release|hotfix)/"

# Verify develop has all changes
git log develop --oneline -n 5

# Ensure main and develop are synchronized
git rev-list --left-right --count main...develop

# If branches diverged during recovery:
git checkout develop
git merge main --no-ff -m "Sync: merge main into develop after recovery"
git push origin develop
```

5. **PREVENTION TIPS**
- Always sync branches before starting (Step 0)
- Commit frequently to minimize conflict scope
- If conflicts are complex, consider manual git flow
- Keep backup branch: `git branch backup-$(date +%s)` before operations

## EXPECTED OUTPUT:
```
üöÄ Git Flow Automation Complete!

Changes detected: 5 files (3 added, 2 modified)
Type: Feature (new functionality detected)
Branch: feature/metadata-signatures
Commit: "feat: add metadata and signature support for CAS"
Version: 0.2.0 ‚Üí 0.3.0 (minor bump for feature)

‚úÖ All branches and tags pushed successfully!
```

User input: $ARGUMENTS